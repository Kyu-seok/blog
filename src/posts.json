[{"id":1625670000,"title":"Deadlock","author":"Kyu Seok Yeum   ","date":"July 8, 2021","content":"## Intro\nDeadlock is a state when all process enter asleep state due to waiting of requested resources held by one another.\n\nexample of resources are : CPU, RAM, virtual memory, hard disk and etc.\n\nwe can differenctiate the resources by\n* Preemptive resources **vs** Non-Preemptive resources\n* Mutually exclusive resources **vs** Global resources\n* Serially reusable resources **vs** Non-reusable resources\n\nExample of deadlock)\nlet there is 2 process (P1, P2), 2 resources (R1, R2)\n\n| Process 1  | time | Process 2  |\n| ---------- | ---- | ---------- |\n| ...        | t1   | ...        |\n| request R2 | t2   | ...        |\n| ...        | t3   | request R1 |\n| request R1 | t4   | ...        |\n| ...        | t5   | request R2 |\n| ...        | t6   | ...        |\n| release R1 | t7   | ...        |\n| ...        | t8   | release R1 |\n| release R2 | t9   | ...        |\n| ...        | t10  | release R2 |\n| ...        | t11  | ...        |\n\nfrom above table, we can see that deadlock occurse in the system at *t5*, as both process P1 and P2 is wating for R1 and R2 respectively.\n\n&nbsp;\n\n## Graph model\n\nThere are 2 deadlock model used in representing deadlock which are \n1. Graph model\n2. State transition model\n\n###### Graph model\n![graph model p-1]()\n\n\n###### State transition model\n\n| state | R units allocated | request |\n| ----- | ----------------- | ------- |\n| 0     | 0                 | x       |\n| 1     | 0                 | o       |\n| 2     | 1                 | x       |\n| 3     | 1                 | o       |\n| 4     | 2                 | x       |\n\n![state transition model p-2]()\n\n*S33* is a deadlock as if system enters S33, there is no other state that it points to, which means that the system is stuck.\n\n&nbsp;\n\n___\n\n##### Conditions for deadlock to occur\n\n> * Exclusive use of resource\n> * Non-preemptive resources\n> * Hold and Wait\n> * circular wait\n  \n&nbsp;\n## Deadlock Prevention\n\nDeadlock prevention can be done by removing *one* condition that casue deadlock.\n\n1. Removal of Exclusive use of resource ( make all resources global )\n     \n     - This method is physically impossible as program cannot be built with global resources completely.\n\n2. Removal of Non-Preemptive resources ( make all resources preemptive )\n   \n   - Physically impossible\n   - This method can be achieved similarly by process returning all holding resources when requested resource cannot be recieved. However time and resource is wasted and it is not practical.\n\n3. Force no hold and wait ( total allocation )\n   \n   - Waste of resources as process may hold all resources that will be used at the end. \n   - This will cause other process to wait which is not efficient.\n\n4. Force no circular wait\n    \n    - This method of prevention is achieved by forcing process to request resources in partial order. \n    - For example, if P1 needs (R1, R2, R3) and P2 needs (R1, R3), as P1 comes first, P1 will be allocated all resources needed in partial order, P1 = R1 -> R2 -> R4. Now, when P2 request for resources, request has to be in partial order so it is R1-> R3. However as R1 is aleady allocated ot P1, P2 will not recieve R1 nor R3.\n    - Waste of resource as R3 is not being used in the system, but P2 is not allowed to use R3.\n\n> summary:\n> prevention can be done by removing a factor causing deadlock. However resources are wasted, and it is impractical on use.\n\n&nbsp;\n\n## Deadlock Avoidance\n\nDeadlock avoidance is done by observing whether there are possibilities of deadlock throughout the entire process. If a process requests resources that might casue a deadlock, deadlock avoidance algorithm postpone the allocation of resources. The system is always maintained in the safe state.\n\n*Safe state*: State that all process are possible to end normally.There is existance of safe sequence which guarantee deadlock does not occur on provided sequence.\n*Unsafe state*: state when there is possibility for deadlock to occur. ( does not mean that deadlock is alaways occuring )\n\nAssumption to use Deadlock Avoidance:\n- There is set number of process\n- There is set number of resources\n- Have information on resources that will be requested from process\n- resources always returned after the use\n\n( Avoidance is not practical due the the assumptions to be made )\n\nAlgorithms used in Deadlock Avoidance:\n1. Dijkstra's banker's algorithm\n2. Habermann's algorithm.\n   \n&nbsp;\n\n###### Dijkstra's banker's algorithm\n\nlet there is resource type R, with 10 resource units, 3 processes\n\n*Case 1*\n| process ID | max claim | cur Alloc | Addtional need |\n| ---------- | --------- | --------- | -------------- |\n| p1         | 3         | 1         | 2              |\n| p2         | 9         | 5         | 4              |\n| p3         | 5         | 2         | 3              |\n\nThere are 10 R units initially, and 8 has been allocated to processes. Now, system has 2 R units left. By following the assumptions, if 2 remaining R is alloacted to P1, it is going to return 3 R after execution. 3 R that is in system, can now be allocated to P3 which returns 5 R after execution. Finally, 4 R can be allocated to P2 to finihsh the program.\n\n*Case 2*\n| process ID | max claim | cur Alloc | Addtional need |\n| ---------- | --------- | --------- | -------------- |\n| p1         | 5         | 1         | 4              |\n| p2         | 9         | 5         | 4              |\n| p3         | 7         | 2         | 5              |\n\nThere are 10 R units initially, and 8 has been allocated to processes. Now, system has 2 R units left. However, all processes need resources more than 2, therefore, there is no safe sequence.\n\n&nbsp;\n\n###### Habermann's algorithm\n\nlet there is 3 types of resources: Ra, Rb, Rc\nnumber of resource units for each type: 10, 5, 7\n\n![Habermann's table P-3]()\n\nInitial resource = 10, 5, 7\nAvailable resource unit = 3, 3, 2\nSafe sequence : P2 -> P4 -> P1 -> P3 -> P5\n\n>summary:\n>avoidance has high overhead as system has to watch program at all times. It still has a low resource utilization problem as there are unused resources to maintain safe sequence. Finally, it is not practical, as there are several assumptions to be made.\n\n&nbsp;\n\n## Deadlock Detection\n\nDeadlock detection allows deadlock in the program. And when deadlock occurs in program, system detects the deadlock and subsequently correct it. Resource Allocation Graph is used to detect deadlock, which is directed, bipartite graph.\n\nG = ( N , E )\nN = { Np, Nr } ,\nwhere Np = set of process { P1, P2, P3, ..., Pn} , Nr = set of resources { R1, R2, R3, ..., Rn}\n\n![RAG P-4]()\n\nP -> R : request\nP <- R : allocation\n\nBy eliminating edge in RAG, we can determine if system is in a deadlock or not. If all edges are completely reduced in RAG, it means that there is no deadlock.\n\n![RAG example in phoe P-5]()\n![RAG example in phoe P-6]()\n\n>summary:\n>deadlock detection has overhead as detecting algorithm is running on the program execution.\n\n&nbsp;\n\n## Deadlock Recovery\n\nThere are 2 methods used in recovery\n1. Process termination\n   - This method terminate process that is in deadlock state, it ensures that deadlock is resolved with certainty and speed. But expense is high as partial computations will be lost. This approach has high overhead because after each abort, an algorithm must determine whether the system is still in deadlock. Several factors must be considered such as priority and age of the process.\n\n2. Resource preemption\n   - Resources allocated to various processes may be successively preempted and allocated to other processes until the deadlock is broken.\n\n&nbsp;\n\nCheckpoint restart is done after process has aborted. This is doneby process being context saved in specific checkpoints. This is also called as rollback."},{"id":1625410800,"title":"Why Linux over Windows OS?","author":"Your boy Q","date":"July 5, 2021","content":"\nSimply because even Microsoft uses Linux for their servers."},{"id":1625065200,"title":"If you are a programmer ","author":"Your boy Q","date":"July 1, 2021","content":"\nIf you are a programmer, you must know c/c++. \nIt is a mother language above all computer languages.\n\n__Below is from \"C wikipedia\"__\n\nC (/siÀê/, as in the letter c) is a general-purpose, procedural computer programming language supporting structured programming, lexical variable scope, and recursion, with a static type system. By design, C provides constructs that map efficiently to typical machine instructions. It has found lasting use in applications previously coded in assembly language. Such applications include operating systems and various application software for computer architectures that range from supercomputers to PLCs and embedded systems.\n\nA successor to the programming language B, C was originally developed at Bell Labs by Dennis Ritchie between 1972 and 1973 to construct utilities running on Unix. It was applied to re-implementing the kernel of the Unix operating system.[6] During the 1980s, C gradually gained popularity. It has become one of the most widely used programming languages,[7][8] with C compilers from various vendors available for the majority of existing computer architectures and operating systems. C has been standardized by the ANSI since 1989 (ANSI C) and by the International Organization for Standardization (ISO).\n\nC is an imperative procedural language. It was designed to be compiled to provide low-level access to memory and language constructs that map efficiently to machine instructions, all with minimal runtime support. Despite its low-level capabilities, the language was designed to encourage cross-platform programming. A standards-compliant C program written with portability in mind can be compiled for a wide variety of computer platforms and operating systems with few changes to its source code.[9]\n\nAs of January 2021, C was ranked first in the TIOBE index, a measure of the popularity of programming languages, moving up from the no. 2 spot the previous year.[10]\n\nLike most procedural languages in the ALGOL tradition, C has facilities for structured programming and allows lexical variable scope and recursion. Its static type system prevents unintended operations. In C, all executable code is contained within subroutines (also called \"functions\", though not strictly in the sense of functional programming). Function parameters are always passed by value (except arrays). Pass-by-reference is simulated in C by explicitly passing pointer values. C program source text is free-format, using the semicolon as a statement terminator and curly braces for grouping blocks of statements.\n\nThe C language also exhibits the following characteristics:\n\nThe language has a small, fixed number of keywords, including a full set of control flow primitives: if/else, for, do/while, while, and switch. User-defined names are not distinguished from keywords by any kind of sigil.\nIt has a large number of arithmetic, bitwise, and logic operators: +,+=,++,&,||, etc.\nMore than one assignment may be performed in a single statement.\nFunctions:\nFunction return values can be ignored, when not needed.\nFunction and data pointers permit ad hoc run-time polymorphism.\nFunctions may not be defined within the lexical scope of other functions.\nData typing is static, but weakly enforced; all data has a type, but implicit conversions are possible.\nDeclaration syntax mimics usage context. C has no \"define\" keyword; instead, a statement beginning with the name of a type is taken as a declaration. There is no \"function\" keyword; instead, a function is indicated by the presence of a parenthesized argument list.\nUser-defined (typedef) and compound types are possible.\nHeterogeneous aggregate data types (struct) allow related data elements to be accessed and assigned as a unit.\nUnion is a structure with overlapping members; only the last member stored is valid.\nArray indexing is a secondary notation, defined in terms of pointer arithmetic. Unlike structs, arrays are not first-class objects: they cannot be assigned or compared using single built-in operators. There is no \"array\" keyword in use or definition; instead, square brackets indicate arrays syntactically, for example month[11].\nEnumerated types are possible with the enum keyword. They are freely interconvertible with integers.\nStrings are not a distinct data type, but are conventionally implemented as null-terminated character arrays.\nLow-level access to computer memory is possible by converting machine addresses to typed pointers.\nProcedures (subroutines not returning values) are a special case of function, with an untyped return type void.\nA preprocessor performs macro definition, source code file inclusion, and conditional compilation.\nThere is a basic form of modularity: files can be compiled separately and linked together, with control over which functions and data objects are visible to other files via static and extern attributes.\nComplex functionality such as I/O, string manipulation, and mathematical functions are consistently delegated to library routines.\nWhile C does not include certain features found in other languages (such as object orientation and garbage collection), these can be implemented or emulated, often through the use of external libraries (e.g., the GLib Object System or the Boehm garbage collector).\n\nRelations to other languages\nMany later languages have borrowed directly or indirectly from C, including C++, C#, Unix's C shell, D, Go, Java, JavaScript (including transpilers), Julia, Limbo, LPC, Objective-C, Perl, PHP, Python, Ruby, Rust, Swift, Verilog and SystemVerilog (hardware description languages).[5] These languages have drawn many of their control structures and other basic features from C. Most of them (Python being a dramatic exception) also express highly similar syntax to C, and they tend to combine the recognizable expression and statement syntax of C with underlying type systems, data models, and semantics that can be radically different."},{"id":1624978800,"title":"My First Post!","author":"Kyu Seok Yeum   ","date":"June 30, 2021","content":"\nWelcome to My Blog!\nThis blog is my skill blog, and ill be posting about things I've learned on here.\n"}]